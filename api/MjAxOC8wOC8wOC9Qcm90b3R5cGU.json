{"title":"Prototype","date":"2018-08-08T10:07:02.000Z","link":"2018/08/08/Prototype","comments":true,"updated":"2019-08-31T10:23:42.507Z","content":"<h4 id=\"1-原型（Prototype）\">1.原型（Prototype）<a href=\"2018/08/08/Prototype#1-原型（Prototype）\"></a></h4><h5 id=\"1-1-原型的介绍\">1.1 原型的介绍<a href=\"2018/08/08/Prototype#1-1-原型的介绍\"></a></h5><p>原型的作用：① 存放函数的所有对象公共的属性和方法的信息</p>\n<pre><code>②  JS中的继承</code></pre><p>凡是构造函数的所有对象公共的信息我们都应该放在函数原型中。</p>\n<p>【如何向原型中追加信息】​    </p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person()&#123;&#125;</span><br><span class=\"line\">Person.prototype.country = &quot;中国&quot;;</span><br><span class=\"line\">Person.prototype.say = function()&#123;&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>【如何访问原型信息】</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p = new Person();</span><br><span class=\"line\">console.log(p.country);</span><br><span class=\"line\">p.say();</span><br></pre></td></tr></table></div></figure>\n\n<h5 id=\"1-2-prototype-和-proto\">1.2 prototype 和 __ proto __<a href=\"2018/08/08/Prototype#1-2-prototype-和-proto\"></a></h5><p>prototype代表函数的原型对象</p>\n<p>__ proto __ 指的是对象的__ proto__属性</p>\n<p><code>**对象的__ proto __ 属性指向函数的原型**</code></p>\n<h5 id=\"1-3-prototype-proto-和构造函数之间的关系\">1.3 prototype  __ proto __ 和构造函数之间的关系<a href=\"2018/08/08/Prototype#1-3-prototype-proto-和构造函数之间的关系\"></a></h5><p><code>函数有一个prototype属性，这个属性表示函数的原型信息（放的是所有对象公用的属性和方法）</code></p>\n<p><code>对象有一个__ proto__ 属性，这个属性指向函数的原型</code></p>\n<p><code>函数的原型中有一个constructor，指向函数本身</code></p>\n<p><img src=\"/2018/08/08/Prototype/1.jpg\" alt class=\"article-img\"></p>\n<h4 id=\"2-继承\">2.继承<a href=\"2018/08/08/Prototype#2-继承\"></a></h4><p>函数的原型中有如下信息：</p>\n<p>① 所有对象公共的属性和方法</p>\n<p>② 构造器</p>\n<p>③ __ proto __ (指向父亲的原型)</p>\n<h5 id=\"2-1-原型链\">2.1 原型链<a href=\"2018/08/08/Prototype#2-1-原型链\"></a></h5><p><img src=\"/2018/08/08/Prototype/2.jpg\" alt class=\"article-img\"></p>\n<h5 id=\"2-2-继承\">2.2 继承<a href=\"2018/08/08/Prototype#2-2-继承\"></a></h5><p>JS 不是面向对象，是基于对象，JS中没有面向对象很多概念，在JS中是通过构造函数来模拟Class。</p>\n<p>我们这边说的继承不是传统面向对象编程中继承的概念，JS中的继承是通过原型链来完成的。</p>\n<p>当我们学习了继承之后，我们可以把不同的函数的公共的属性和方法写在父函数里面，然后让子函数继承父函数，子函数就可以拥有父函数的信息了。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Animal(name,gender)&#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">    this.gender = gender;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Dog()&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Cat()&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h5 id=\"2-3-继承的原型\">2.3 继承的原型<a href=\"2018/08/08/Prototype#2-3-继承的原型\"></a></h5><p>函数.prototype = new 父();</p>\n<p>直接修改函数的原型，让其为一个new出来的父亲对象</p>\n<p>【优点】可以获取父亲对象中的属性以及父亲对象原型中的信息</p>\n<p>【缺点】创建子对象不能指定子对象的属性</p>\n<p><img src=\"/2018/08/08/Prototype/3.jpg\" alt class=\"article-img\"></p>\n<h5 id=\"2-4-构造函数的属性继承\">2.4 构造函数的属性继承<a href=\"2018/08/08/Prototype#2-4-构造函数的属性继承\"></a></h5><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person(name,age)&#123;</span><br><span class=\"line\">\tthis.name = name;</span><br><span class=\"line\">\tthis.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.portotype.country = &quot;中国&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">function Student(name,age)&#123;</span><br><span class=\"line\">    Person.call(this,name,age);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>构造函数的属性继承优缺点：好处是创建子对象的时候可以指定子对象的属性信息，坏处是不能够获取父对象原型中的信息。</p>\n<h5 id=\"2-5-组合继承\">2.5 组合继承<a href=\"2018/08/08/Prototype#2-5-组合继承\"></a></h5><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//父亲</span><br><span class=\"line\">function Person(name,age)&#123;</span><br><span class=\"line\">    this,name = name;</span><br><span class=\"line\">    this.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.country = &quot;中国&quot;;</span><br><span class=\"line\">//grilfriend是孩子自己的属性</span><br><span class=\"line\">function Student(name,age,grilfriend)&#123;</span><br><span class=\"line\">    //调用父亲的构造方法初始化name和age的值</span><br><span class=\"line\">    Person.call(this,name,age);</span><br><span class=\"line\">    //初始化自己私有的属性信息</span><br><span class=\"line\">    this.grilfriend = grilfriend;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//原型继承</span><br><span class=\"line\">Student.prototype = new Person();</span><br></pre></td></tr></table></div></figure>\n\n<p>组合继承创建子对象的时候既可以指定孩子的自己的属性信息，又可以继承父亲的原型信息。</p>\n<h5 id=\"2-6-继承总结\">2.6 继承总结<a href=\"2018/08/08/Prototype#2-6-继承总结\"></a></h5><p><img src=\"/2018/08/08/Prototype/4.jpg\" alt class=\"article-img\"></p>\n<h5 id=\"2-7-成员搜索的规则\">2.7 成员搜索的规则<a href=\"2018/08/08/Prototype#2-7-成员搜索的规则\"></a></h5><p>当有原型继承的时候，在查找属性的时候，搜索规则如下：</p>\n<p>console.log(p.name);</p>\n<p>1 先找p自己有没有name属性，如果有则用自己的</p>\n<p>2 如果p自己没有，则从p的__ proto__ 所指向的原型对象中去找有没有name属性，如果有，则用原型对象中的</p>\n<p>3 如果p的__ proto__所指向原型对象中没有name属性，则从原型对象中的 proto所指向的原型中去找有没有name属性的父亲，如果有则用</p>\n<p>4 如果没有则沿着原型链继续向上找</p>\n<p>5 直到找到Object的原型对象中没有，则打印undefined。</p>\n","prev":{"title":"文档对象模型","link":"2018/08/26/文档对象模型"},"next":{"title":"CSS样式的深入浅出","link":"2018/07/26/CSS样式的深入浅出-1"},"plink":"http://Li_junhui.github.io.git/2018/08/08/Prototype/"}