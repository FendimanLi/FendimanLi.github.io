{"title":"前端性能的优化","date":"2019-01-03T12:13:00.000Z","link":"2019/01/03/前端性能的优化","comments":true,"updated":"2019-08-31T14:59:26.063Z","content":"<h4 id=\"图片优化\">图片优化<a href=\"2019/01/03/前端性能的优化#图片优化\"></a></h4><h5 id=\"二进制位数与色彩的关系\">二进制位数与色彩的关系<a href=\"2019/01/03/前端性能的优化#二进制位数与色彩的关系\"></a></h5><p>在计算机中，像素用二进制表示。不同的图片格式中像素与二进制位数之间的对应关系是不同的。一个像素对应的二进制位数越多，它可以表示颜色种类就越多，成像效果也就越细腻，文件体积相应也越大。</p>\n<p>一个二进制位表示两种颜色（0|1对应黑|白），如果一种图片格式对应的二进制数有n个，那么它就可以呈现2^n种颜色。</p>\n<h5 id=\"计算图片大小\">计算图片大小<a href=\"2019/01/03/前端性能的优化#计算图片大小\"></a></h5><p>对于一张100 100 像素的图片来说，图片上有10000个像素点，如果每个像素的值是RGBA存储的话，那么也就是说每个像素有4个通道，每个通道1个字节（8位=1个字节），所以该图片的像素大小为39kb左右（10000 1*4/1024)。</p>\n<p>但在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过减少每个像素的调色板来相应的压缩图片的大小。</p>\n<p>了解了如何计算图片的大小的知识，那么对于如何优化图片，想必大家已经有了两个思路了：</p>\n<ul>\n<li><p>减少像素点</p>\n</li>\n<li><p>减少每个像素点能够显示的颜色</p>\n</li>\n</ul>\n<h5 id=\"图片类型的要点\">图片类型的要点<a href=\"2019/01/03/前端性能的优化#图片类型的要点\"></a></h5><p>JPEG/JPG特点： 有损压缩、体积小、加载快、不支持透明，JPG最大的特点是有损压缩。这种高效的压缩算法使它成为了一种非常轻巧的图片格式，另一方面，即使被称为“有损”压缩的方仍然是一种高质量的压缩方式：当我们把图片体积压缩到原有体积的50%以下时，JPG仍然可以保持住60%的品质。但当它处理矢量图形和LOGO等线条感较强、颜色对比强烈的图像时，人为压缩导致的图片模糊会相当明显。</p>\n<p>PNG特点：无损压缩、质量高、体积大、支持透明、PNG是一种无损压缩的高保真的图片格式。8和24，这里都是二进制数的位数。按照我们前置知识里提到的对应关系，8位的PNG最多支持256种颜色，而24位的可以呈现约1600万种颜色。PNG图片具有比JPG更强的色彩表现力，对线条的处更加细腻，对透明度有良好的支持。</p>\n<p>SVG特点： 文本文件、体积小、不失真、兼容性好，SVG是一种基于XML语法的图像格式。它和本文提及的其它图片种类有着本质的不同：SVG对图像的处理不是基于像素点，而是基于对图像的形状描述。</p>\n<p>Base64特点：文本文件、依赖编码、小图标解决方案，Base64并非一种图片格式，而是一种编码方式。Base64和雪碧图一样，是作为小图标解决方案而存在的。</p>\n<p>WebP特点：年轻的全能型选手，WebP像JPEG一样对细节丰富的图片信手拈来，像PNG一样支持透明，像GIF一样可以显示动态图片——-它集多种图片文件格式的优点于一身，但是毕竟年轻，兼容性存在一些问题。</p>\n<h4 id=\"渲染优化\">渲染优化<a href=\"2019/01/03/前端性能的优化#渲染优化\"></a></h4><h5 id=\"客户端渲染\">客户端渲染<a href=\"2019/01/03/前端性能的优化#客户端渲染\"></a></h5><p>在客户端渲染模式下，服务器端会把渲染需要的静态文件发送给客户端，客户端加载过来之后，自己在浏览器里跑一遍js，根据js的运行结果，生成相应的DOM。页面上呈现的内容，你在html源文件里找不到——这正是它的特点。</p>\n<h5 id=\"服务端渲染\">服务端渲染<a href=\"2019/01/03/前端性能的优化#服务端渲染\"></a></h5><p>在服务器渲染的模式下，当用户第一次请求页面时，由服务器把需要的组件或页面渲染成HTML字符串，然后把它返回给客户端。页面上呈现的内容，我们在html源文件里也能找到。服务端渲染解决一个非常关键的性能问题——首屏加载速度过慢，也解决了SEO搜索引擎的问题。</p>\n<h5 id=\"浏览器渲染过程解析\">浏览器渲染过程解析<a href=\"2019/01/03/前端性能的优化#浏览器渲染过程解析\"></a></h5><p>浏览器渲染机制一般分为以下几个步骤：</p>\n<ul>\n<li>处理HTML生成DOM树。</li>\n<li>处理CSS构建CSSOM树。</li>\n<li>将DOM和CSSOM合并成一个渲染树。</li>\n<li>根据渲染树来布局，计算每个节点的位置。</li>\n<li>调用GPU绘制，合成图层，显示在屏幕上。</li>\n</ul>\n<p>在渲染DOM的时候，浏览器所做的工作实际上是：</p>\n<ul>\n<li>获取DOM后分隔为多个图层</li>\n<li>对每个图层的节点计算样式结果（Recalculate style）</li>\n<li>为每个节点生成图形和位置（Layout）</li>\n<li>将每个节点绘制填充到图层中（Paint Setup和Paint）</li>\n<li>图层作为纹理上传到GPU</li>\n<li>复合多个图层到页面上生成最终的屏幕图像（Composite Layers）</li>\n</ul>\n<h5 id=\"基于渲染流程的CSS优化建议\">基于渲染流程的CSS优化建议<a href=\"2019/01/03/前端性能的优化#基于渲染流程的CSS优化建议\"></a></h5><p>CSS选择符是从右到左进行匹配的，比如#mylist li {}实际开销相当高。</p>\n<ul>\n<li>避免使用通配符，只对需要用到的元素进行选择。</li>\n<li>关注可以通过继承实现的属性，避免重复匹配重复定义。</li>\n<li>少用标签选择器。如果可以，用类选择器替代。错误：#dataList li{}  正确：.dataList{}</li>\n<li>不要画蛇添足，id和class选择器不应该被多余标签选择器托后腿。错误：.dataList#title  正确：#title</li>\n<li>减少嵌套。后代选择器的开销是最高的，因此我们应该尽量将选择器的深度降到最低（最高不要超过三层），尽可能使用类来关联每一个标签元素。</li>\n</ul>\n<h5 id=\"CSS堵塞\">CSS堵塞<a href=\"2019/01/03/前端性能的优化#CSS堵塞\"></a></h5><p>CSS是堵塞的资源。浏览器在构建CSSOM的过程中，不会渲染任何已处理的内容。即使DOM解析完毕了，只要CSSOM不OK，那么渲染这个事就不OK。我们将CSS放在head标签里和尽快启用CDN实现静态资源加载速度的优化。</p>\n<h5 id=\"JS堵塞\">JS堵塞<a href=\"2019/01/03/前端性能的优化#JS堵塞\"></a></h5><p>JS引擎是独立于渲染引擎存在的。我们的JS代码在文档何处插入，就在何处执行。当HTML解析器遇到一个script标签时，它会暂停渲染过程，将控制权交给JS引擎。JS引擎对内联的JS代码会直接执行，对外部文件还要先获取到脚本。在进行执行。等JS引擎运行完毕，浏览器又会把控制权还给渲染引擎，继续CSSOM和DOM的构建。</p>\n<h4 id=\"DOM渲染优化\">DOM渲染优化<a href=\"2019/01/03/前端性能的优化#DOM渲染优化\"></a></h4><p>先了解回流和重绘</p>\n<ul>\n<li><p>回流：当我们对DOM的修改引发了DOM几何尺寸的变化（比如修改元素的宽高或隐藏元素等）时，浏览器需要重新计算元素的几何属性，然后再计算的结果绘制出来。这个过程就是回流也叫重排。</p>\n</li>\n<li><p>重绘：当我们对DOM的修改导致样式的变化、并未影响几何属性（比如修改了颜色或背景）时，浏览器不需要重新计算元素的几何属性。直接为该元素绘制新的样式，这个过程叫做重绘。</p>\n</li>\n</ul>\n<p>重绘不一定引起重排，重排一定引起重绘。重排比重绘做的事情更多，带来的开销也更大。在开发中，要从代码层面出发，尽可能把回流和重绘的次数最小化。</p>\n<p>例子解析</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=<span class=\"string\">\"en\"</span>&gt;</span><br><span class=\"line\">    &lt;head&gt;  </span><br><span class=\"line\">        &lt;meta charset=<span class=\"string\">\"UTF-8\"</span>&gt;  </span><br><span class=\"line\">        &lt;meta name=<span class=\"string\">\"viewport\"</span> content=<span class=\"string\">\"width=device-width, initial-scale=1.0\"</span>&gt;  </span><br><span class=\"line\">        &lt;meta http-equiv=<span class=\"string\">\"X-UA-Compatible\"</span> content=<span class=\"string\">\"ie=edge\"</span>&gt;  </span><br><span class=\"line\">        &lt;title&gt;DOM操作测试&lt;<span class=\"regexp\">/title&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>head&gt;</span><br><span class=\"line\">    &lt;body&gt;  </span><br><span class=\"line\">        &lt;div id=<span class=\"string\">\"container\"</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/body&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>html&gt;</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> count=<span class=\"number\">0</span>;count&lt;<span class=\"number\">10000</span>;count++)&#123;   </span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'container'</span>).innerHTML+=<span class=\"string\">'&lt;span&gt;我是一个小测试&lt;/span&gt;'</span>  </span><br><span class=\"line\">    <span class=\"comment\">//我们每一次循环都调用 DOM 接口重新获取了一次 container 元素，额外开销</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>进化一：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 只获取一次containerlet </span></span><br><span class=\"line\">container = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'container'</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> count=<span class=\"number\">0</span>;count&lt;<span class=\"number\">10000</span>;count++)&#123;   </span><br><span class=\"line\">    container.innerHTML += <span class=\"string\">'&lt;span&gt;我是一个小测试&lt;/span&gt;'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>进化二：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//减少不必要的DOM更改</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> container = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'container'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> content = <span class=\"string\">''</span><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> count=<span class=\"number\">0</span>;count&lt;<span class=\"number\">10000</span>;count++)&#123;   </span><br><span class=\"line\">    <span class=\"comment\">// 先对内容进行操作  </span></span><br><span class=\"line\">    content += <span class=\"string\">'&lt;span&gt;我是一个小测试&lt;/span&gt;'</span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\">    <span class=\"comment\">// 内容处理好了,最后再触发DOM的更改container.innerHTML = content</span></span><br></pre></td></tr></table></div></figure>\n\n<p>事实上，考虑的js运行速度，比DOM速度快得多。我们减少DOM的核心思路，就是让js给DOM分压。</p>\n<p>在DOM Fragment中，DocumentFragment接口表示一个没有父级文件的最小文档对象。他被当做一个轻量版的Document使用，用于处理排版好的或尚未打理好格式的XML片段。因为DocumentFragment不是真实DOM树的一部分，它的变化不会引起DOM树 的重新渲染，且不会导致性能等问题。</p>\n<p>进化三：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> container = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'container'</span>)</span><br><span class=\"line\"><span class=\"comment\">// 创建一个DOM Fragment对象作为容器</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> content = <span class=\"built_in\">document</span>.createDocumentFragment()</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> count=<span class=\"number\">0</span>;count&lt;<span class=\"number\">10000</span>;count++)&#123;  </span><br><span class=\"line\">    <span class=\"comment\">// span此时可以通过DOM API去创建  </span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> oSpan = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"span\"</span>)  </span><br><span class=\"line\">    oSpan.innerHTML = <span class=\"string\">'我是一个小测试'</span>  </span><br><span class=\"line\">    <span class=\"comment\">// 像操作真实DOM一样操作DOM Fragment对象  </span></span><br><span class=\"line\">    content.appendChild(oSpan)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 内容处理好了,最后再触发真实DOM的更改container.appendChild(content)</span></span><br></pre></td></tr></table></div></figure>\n\n<p>进化四 </p>\n<p>当涉及到过万调用数据进行渲染，且要求不卡住画面，如何解决？<br>如何在不卡住画面的情况下渲染数据，也就是说不能一次性将几万条数据渲染出来，而应该一次渲染部分DOM，那么就可以通过RequestAnimationFame来16ms刷新一次。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;  </span><br><span class=\"line\">    &lt;head&gt;    </span><br><span class=\"line\">        &lt;meta charset=\"UTF-8\" /&gt;    </span><br><span class=\"line\">        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;    </span><br><span class=\"line\">        &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt;    </span><br><span class=\"line\">        &lt;title&gt;Document&lt;/title&gt;  </span><br><span class=\"line\">    &lt;/head&gt;  </span><br><span class=\"line\">    &lt;body&gt;    </span><br><span class=\"line\">        &lt;ul&gt;      </span><br><span class=\"line\">            控件   </span><br><span class=\"line\">        &lt;/ul&gt;    </span><br><span class=\"line\">        &lt;script&gt;      </span><br><span class=\"line\">            setTimeout(() =&gt; &#123;        </span><br><span class=\"line\">                // 插入十万条数据        </span><br><span class=\"line\">                const total = 100000        </span><br><span class=\"line\">                // 一次插入 20 条，如果觉得性能不好就减少        </span><br><span class=\"line\">                const once = 20        </span><br><span class=\"line\">                // 渲染数据总共需要几次        </span><br><span class=\"line\">                const loopCount = total / once        </span><br><span class=\"line\">                let countOfRender = 0        </span><br><span class=\"line\">                let ul = document.querySelector('ul')        </span><br><span class=\"line\">                function add() &#123;          </span><br><span class=\"line\">                    // 优化性能，插入不会造成回流          </span><br><span class=\"line\">                    const fragment = document.createDocumentFragment()          </span><br><span class=\"line\">                    for (let i = 0; i &lt; once; i++) &#123;            </span><br><span class=\"line\">                        const li = document.createElement('li')            </span><br><span class=\"line\">                        li.innerText = Math.floor(Math.random() * total)            </span><br><span class=\"line\">                        fragment.appendChild(li)</span><br><span class=\"line\">                    &#125;          </span><br><span class=\"line\">                    ul.appendChild(fragment)          </span><br><span class=\"line\">                    countOfRender += 1          </span><br><span class=\"line\">                    loop()        </span><br><span class=\"line\">                &#125;        </span><br><span class=\"line\">                function loop() &#123;          </span><br><span class=\"line\">                    if (countOfRender &lt; loopCount) &#123;</span><br><span class=\"line\">                        window.requestAnimationFrame(add)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;        </span><br><span class=\"line\">                loop()</span><br><span class=\"line\">            &#125;, 0)   </span><br><span class=\"line\">        &lt;/script&gt; </span><br><span class=\"line\">    &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></div></figure>\n\n<p>window. rquestAnimationFrame()方法告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画，该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。</p>\n<p>注意：若您想在下一次重绘时产生另一个动画画面，您的回调例程必须调用。</p>\n<h5 id=\"EventLoop\">EventLoop<a href=\"2019/01/03/前端性能的优化#EventLoop\"></a></h5><p>我们先了解javascript运作机制，对渲染是有很大帮助的。</p>\n<p>事件循环中的异步队列有两种：macro（宏队列）和micro(微队列）</p>\n<p>常见的macro-task，比如：setTimeout、setInteval、setImmediate、script（整体代码）、IO操作、UI渲染等</p>\n<p>常见的micro-task，比如：process.nextTick 、Promise、MutationObserver等。</p>\n<p>例子分析：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// task是一个用于修改DOM的回调</span></span><br><span class=\"line\">setTimeout(task, <span class=\"number\">0</span>)<span class=\"comment\">// task是一个用于修改DOM的回调</span></span><br></pre></td></tr></table></div></figure>\n\n<p>上面代码，现在task被推入的macro队列。但是因为script脚本本身就是一个macro任务，所以每次执行完js脚本之后，下一个任务就是要去处理micro队列，再往下就去执行一次render，必须等待下一次的loop。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve().then(task)</span><br></pre></td></tr></table></div></figure>\n\n<p>上面的代码，我们结束了对script脚本的执行，是不是紧接着去处理micro-task队列了吗？micro-task处理完，DOM修改好，紧接着就可以走render流程了，不需要再消耗多余的一次渲染，不需要再等待一轮事件的循环，直接为用户呈现最及时的更新结果。</p>\n<p>上面说了重绘与重排，Event loop，很多人不知道这两种是有关系的</p>\n<ul>\n<li><p>当Event loop执行完Microtasks后，会判断document是否需要更新。因为浏览器是60Hz的刷新率，所以16ms才会更新一次。</p>\n</li>\n<li><p>然后判断是否有resize和scroll，有的话去触发事件，所以resize和scroll事件也是至少16ms才会触发一次，并且自带节流功能。</p>\n</li>\n<li><p>判断是否触发了媒体查询</p>\n</li>\n<li><p>更新动画并且发送事件</p>\n</li>\n<li><p>判断是否有全屏操作事件</p>\n</li>\n<li><p>执行requestAnimationFrame的回调</p>\n</li>\n<li><p>执行IntersectionObserver回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好。</p>\n</li>\n<li><p>更新界面</p>\n</li>\n<li><p>以上就是一帧中可能做得事情。如果在一帧中有空闲的时间，就会执行rquestIeCallback回调函数。</p>\n</li>\n</ul>\n<h5 id=\"节流与抖动\">节流与抖动<a href=\"2019/01/03/前端性能的优化#节流与抖动\"></a></h5><p>当用户进行滚动触发scroll事件，用户的每一次滚动都将触发我们的监听函数，函数执行是吃性能的，频繁的响应某个事件将造成大量不必要的页面计算。因此，我们需要针对那些有可能被频繁的触发的事件进一步的优化。节流与防抖就很有必要了。</p>\n","prev":{"title":"React中的数据管理","link":"2019/03/16/React中的数据管理"},"next":{"title":"Vue中的小技巧","link":"2018/12/10/Vue中的小技巧"},"plink":"http://Li_junhui.github.io.git/2019/01/03/前端性能的优化/"}